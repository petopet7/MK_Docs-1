{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction to Movie Recommendation Python Package","text":""},{"location":"#overview","title":"Overview","text":"<p>This package is designed to simulate a movie database environment. It includes modules for generating mock data, managing database interactions, handling API requests, recommending movies, and setting up the entire application. It's an ideal toolkit for developers working on movie-related applications, especially in a testing or development environment.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Data Generation: Generate mock data for movies, users, ratings, etc.</li> <li>Database Management: Handle all database-related operations.</li> <li>API: Define API endpoints for movie data interaction.</li> <li>Recommender System: Provide movie recommendations.</li> <li>Schema Management: Define and manage the database schema.</li> <li>SQL Interactions: Perform complex SQL queries and operations.</li> <li>Setup and Installation: Easily set up the environment for the application.</li> </ul>"},{"location":"#target-audience","title":"Target Audience","text":"<p>This package is primarily targeted at developers and testers who need to create a simulated environment for a movie database application. It can also be used by data analysts and educators for demonstration purposes.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with this package, clone the repository and install the required dependencies. Detailed instructions are provided in the user guide below.</p>"},{"location":"Guide/","title":"User's Guide","text":""},{"location":"Guide/#installation","title":"Installation","text":"<ol> <li>Clone the repository: <code>git clone [repository-url]</code></li> <li>Navigate to the project directory: <code>cd [project-directory]</code></li> <li>Install dependencies: <code>pip install -r requirements.txt</code></li> </ol>"},{"location":"Guide/#setting-up-the-database","title":"Setting Up the Database","text":"<p>Run the <code>setup.py</code> script to set up the initial database and environment:</p> <pre><code>python setup.py\n</code></pre> <p>Run this line to install our package</p> <pre><code>!pip install movie_recommend\n</code></pre>"},{"location":"Guide/#data-generation","title":"Data Generation","text":"<p>This section shows how to generate sample data using the package.</p> <pre><code>from etl.data_preperation.data_generator import .\n\nNUMBER_OF_MOVIES = 450\nNUMBER_OF_LINKS = 270\nNUMBER_OF_RATINGS = 260\nNUMBER_OF_TAGS = 750\nNUMBER_OF_CREDITS = 300\nNUMBER_OF_USERS = 200\n</code></pre> <p>Generating Movie MetaData</p> <pre><code>from etl.data_preperation.data_generator import .\n\nmovie_data = [generate_movie_metadata(movie_id) for movie_id in range(NUMBER_OF_MOVIES)]\nmovie_df = pd.DataFrame(movie_data)\nmovie_df.to_csv('movie_metadata.csv', index=False)\n</code></pre> <p>Generating Ratings Data</p> <pre><code>ratings_data = [generate_ratings(user_id, movie_id) for user_id in range(NUMBER_OF_RATINGS) for movie_id in range(NUMBER_OF_MOVIES)]\nratings_df = pd.DataFrame(ratings_data)\nratings_df.to_csv('ratings.csv', index=False)\n</code></pre> <p>Generating Credits Data</p> <pre><code>credits = [generate_credits(movie_id) for movie_id in range(NUMBER_OF_CREDITS )]\npd.DataFrame(credits).head()\ncredits_df = pd.DataFrame(credits)\ncredits_df.to_csv('credits_data.csv', index=False)\n</code></pre> <p>Generating Keywords Data</p> <pre><code>keywords = [generate_keywords(movie_id) for movie_id in range(NUMBER_OF_MOVIES)]\nkeywords_df = pd.DataFrame(keywords)\nkeywords_df_df = pd.DataFrame(keywords)\nkeywords_df.to_csv('keywords.csv', index=False)\n</code></pre> <p>Generating User Data</p> <pre><code>users = [generate_user(user_id) for user_id in range(1, NUMBER_OF_USERS + 1)]\nusers_df = pd.DataFrame(users)\nusers_df.to_csv('users.csv', index=False)\n</code></pre>"},{"location":"Guide/#movie-recommendation-system-schema-setup","title":"Movie Recommendation System Schema Setup","text":"<p>This code demonstrates the setup and schema definition for a movie recommendation system using SQLAlchemy, a Python SQL toolkit and Object-Relational Mapping (ORM) library.</p> <pre><code>from etl.data_preperation.schema import *\n</code></pre> <p>This simple line will create schema for you movie dataset</p>"},{"location":"Guide/#sql-connection","title":"SQL Connection","text":"<p>Establish a SQL connection and execute a query to retrieve movie data.</p>"},{"location":"Guide/#create-sql-handlers-for-each-table","title":"Create SQL handlers for each table","text":"<pre><code>Inst_movie_metadata = SqlHandler('temp', 'MovieMetadata')\nInst_user = SqlHandler('temp', 'User')\nInst_ratings_small = SqlHandler('temp', 'Ratings_small')\nInst_credits = SqlHandler('temp', 'Credits')\nInst_keywords = SqlHandler('temp', 'plot_keywords')\n</code></pre> <p>##  Load data from respective CSV files</p> <pre><code>movie_data = pd.read_csv('movie_metadata.csv')\nuser_data = pd.read_csv('users.csv')\nratings_data = pd.read_csv('ratings.csv')\ncredits_data = pd.read_csv('credits_data.csv')\nkeywords_data = pd.read_csv('keywords.csv')\n</code></pre> <p>##  Insert data into respective SQL tables</p> <pre><code>Inst_movie_metadata.insert_many(movie_data)\nInst_user.insert_many(user_data)\nInst_ratings_small.insert_many(ratings_data)\nInst_credits.insert_many(credits_data)\nInst_keywords.insert_many(keywords_data)\n</code></pre>"},{"location":"Guide/#close-connections-for-each-table","title":"Close connections for each table","text":"<pre><code>Inst_movie_metadata.close_cnxn()\nInst_user.close_cnxn()\nInst_ratings_small.close_cnxn()\nInst_credits.close_cnxn()\nInst_keywords.close_cnxn()\n</code></pre>"},{"location":"Guide/#recommendation-algorithm","title":"Recommendation Algorithm","text":""},{"location":"Guide/#use-the-recommendation-algorithm-on-the-generated-data","title":"Use the recommendation algorithm on the generated data.","text":"<pre><code>from etl.movie_recommender.check import get_recommendations_for_movie\n\ntest_movie_title = \"Organized mission-critical core\"\nrecommendations = get_recommendations_for_movie(test_movie_title)\n\n# Print recommendations\nprint(f\"Recommendations for '{test_movie_title}':\")\nfor recommendation in recommendations:\n    print(recommendation)\n</code></pre>"},{"location":"Guide/#fastapi-integration","title":"FastAPI Integration","text":""},{"location":"Guide/#example-of-integrating-the-recommendation-algorithm-with-fastapi","title":"Example of integrating the recommendation algorithm with FastAPI.","text":"<pre><code>import uvicorn\nimport os\nimport threading\nimport uvicorn\nfrom etl.api.api import app\n\n\ndef run_server():\n    uvicorn.run(app, host=\"127.0.0.1\", port=5001, log_level=\"info\")\n</code></pre>"},{"location":"Guide/#run-the-server-in-a-separate-thread","title":"Run the server in a separate thread","text":"<pre><code>server_thread = threading.Thread(target=run_server)\nserver_thread.start()\n</code></pre> <p>After this steps copy the host link and paste it in the search bar adding \"docs\" after it. There are different functionalities in the FASTAPI page. We can CREATE a movie, UPDATE a movie, delete a movie in our data. Also there is a function to get recommendation based on the imput of a movie name.</p> <p>With all these steps it will be very easy to run the package even if the user does not have a lot of experience in Python coding.</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#introduction","title":"Introduction","text":"<p>The <code>api.py</code> module is responsible for handling API requests related to the movie data. It defines various endpoints for accessing and manipulating movie-related data.</p>"},{"location":"api/#usage","title":"Usage","text":"<pre><code>from fastapi import FastAPI, HTTPException\nimport sqlite3\nimport logging\nimport os\nfrom pydantic import BaseModel\nfrom typing import Any\nfrom ...movie_recommender.recommender import MovieRecommender\nfrom ...movie_recommender.database import preview\nimport random\n#create instance called app\napp=FastAPI()\n\n\nlogger = logging.getLogger(os.path.basename(__file__))\nlogger.setLevel(logging.DEBUG)\nch = logging.StreamHandler()\nch.setLevel(logging.DEBUG)\n#ch.setFormatter(CustomFormatter())\nlogger.addHandler(ch)\n\n# Defining a function to open a connection to our SQLite database\ndef get_db():\n  db = sqlite3.connect('temp.db')\n  return db\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Initializing\"}\n\n\n\n@app.get(\"/get_data/{movie_id}\")\nasync def get_record(movie_id: int):\n    # Open a connection to the database\n    with get_db() as db:\n        cursor = db.cursor()\n        # Executing a SQL query to fetch the data\n        cursor.execute(f\"SELECT * FROM MovieMetadata WHERE movie_id = {movie_id}\")\n        record = cursor.fetchone()\n\nif record is None:\n    return {\"error\": \"Record not found\"}\n\n# Converting the record to a dictionary \ncolumn_names = [description[0] for description in cursor.description]\nrecord_dict = dict(zip(column_names, record))\nreturn record_dict\n\n\n#Defining a Pydantic model for the data\nclass CreatemovieRequest(BaseModel):\n    movie_id: int\n    title: str\n    budget: int\n    revenue: int\n    release_date: str\n    language: str\n    production_country: str\n    production_company: str\n\n\n# Columns: ['movie_id', 'title', 'budget', 'revenue', 'release_date', 'language', 'production_country', 'production_company']\n\n@app.post(\"/create_data\")\nasync def create_record(new_data: CreatemovieRequest):\n    try:\n        # Opening a database connection using the get_db function\n        db = get_db()\n        cursor = db.cursor()\n\n        # Defining the SQL query to insert data into the table\n        insert_query = \"\"\"\n        INSERT INTO MovieMetadata (\n            movie_id, title, budget, revenue, release_date, language, production_country ,production_company\n        )\n         VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        \"\"\"\n\n    # Executing the insert query with the data from the new_data parameter\n    cursor.execute(insert_query, (\n        new_data.movie_id, new_data.title, new_data.budget,\n        new_data.revenue, new_data.release_date, new_data.language,\n        new_data.production_country, new_data.production_company\n    ))\n\n    # Committing the transaction to save the data in the database\n    db.commit()\n\n    return {\"message\": \"Record created successfully\"}\nexcept Exception as e:\n    logger.error(f\"Failed to insert data: {str(e)}\")\n    raise HTTPException(status_code=500, detail=f\"Failed to insert data: {str(e)}\")\nfinally:\n    # Closing the database connection in the 'finally' block\n    db.close()\n\n\nclass UpdateRecordRequest(BaseModel):\n    column_name: str  # The type that column gets\n    new_value: Any # As it can be both integer and str, defined as Any. Later can find better solution\n    movie_id: int  # The type that the movie_id is\n\n@app.put(\"/update_data\")\nasync def update_record(update_request: UpdateRecordRequest):\ntry:\n    # Opening a database connection using the get_db function\n    db = get_db()\n    cursor = db.cursor()\n\n    # Defining the SQL query to update the specified column for the given record ID\n    update_query = f\"UPDATE MovieMetadata SET {update_request.column_name} = ? WHERE movie_id = ?\"\n\n    # Executing the update query with the new value and record ID\n    cursor.execute(update_query, (update_request.new_value, update_request.movie_id))\n\n    # Committing the transaction to save the data in the database\n    db.commit()\n\n    return {\"message\": \"Record updated successfully\"}\nexcept Exception as e:\n    raise HTTPException(status_code=500, detail=f\"Failed to update data: {str(e)}\")\nfinally:\n    # Closing the database connection in the 'finally' block\n    db.close()\n\n@app.get(\"/recomend\")\nasync def recomend(title: str):\n# Open a connection to the database\nmovie_data = preview('MovieMetadata')\nrecommender = MovieRecommender(movie_data)\nrecommendations = recommender.recommend_movies(title, num_recommendations=10)\nif recommendations is None:\n    return {\"error\": \"Record not found\"}\n\n\ndb = get_db()\ncursor = db.cursor()\n\n# Defining the SQL query to insert data into the table\ninsert_query = \"\"\"\nINSERT INTO inout (\n    movie_id, input_movie, output_recommendations\n)\nVALUES (?, ?, ?)\n\"\"\"\n# Generate a random movie_id\nmovie_id = recommender.get_movie_id(title)  # Adjust the range as needed\n\n# Convert the list of recommendations to a long string\nrecommendations_str = ', '.join(recommendations)\n# Executing the insert query with the data\ncursor.execute(insert_query, (int(movie_id), title, recommendations_str))\n\n# Committing the transaction to save the data in the database\ndb.commit()\n\nreturn recommendations\n</code></pre>"},{"location":"api/#imput-for-recommendation","title":"Imput for recommendation","text":""},{"location":"api/#recommendation-outcome","title":"Recommendation outcome","text":"<p>...</p>"},{"location":"database/","title":"Database","text":""},{"location":"database/#introduction","title":"Introduction","text":"<p>This module handles the database interactions for the movie application. It includes functionalities for creating and managing the database structure and performing CRUD operations.</p>"},{"location":"database/#usage","title":"Usage","text":"<pre><code>import sqlite3\nimport pandas as pd\n\n\ndef preview(table):\n  # Open a connection to the database file\n  conn = sqlite3.connect('temp.db')\n\n  # Create a cursor object to execute SQL commands\n  cursor = conn.cursor()\n\n  # Execute a SQL query to select data from the table\n  cursor.execute(f\"SELECT * FROM {table}\")\n\n  # Fetch all the data from the executed query\n  data = cursor.fetchall()\n\n  # Get column names from the cursor description\n  column_names = [desc[0] for desc in cursor.description]\n\n  # Create a DataFrame from the data and assign column names\n  df = pd.DataFrame(data, columns=column_names)\n\n  # Print the DataFrame\n  print(df)\n\n  # Close the cursor and the connection\n  cursor.close()\n  conn.close()\n\n  return df\n</code></pre> <p>...</p>"},{"location":"generator/","title":"Data Generator","text":""},{"location":"generator/#introduction","title":"Introduction","text":"<p>The <code>data_generator</code> module is designed to create mock data for movies, users, and their interactions. This module is especially useful for simulating a movie database environment for testing and development purposes.</p>"},{"location":"generator/#key-functions","title":"Key Functions","text":"<ul> <li><code>generate_movie_metadata(movie_id)</code>: Generates random metadata for a movie.</li> <li><code>generate_user(user_id)</code>: Creates a fake user profile.</li> <li><code>generate_ratings(user_id, movie_id)</code>: Generates a random movie rating by a user.</li> <li><code>generate_credits(movie_id)</code>: Creates a random list of cast and crew for a movie.</li> <li><code>generate_keywords(movie_id)</code>: Generates random keywords related to a movie.</li> </ul>"},{"location":"generator/#usage-example","title":"Usage Example","text":"<p>This section shows how the data is generated.</p> <pre><code>Declaring Constants\nNUMBER_OF_MOVIES = 450\nNUMBER_OF_LINKS = 270\nNUMBER_OF_RATINGS = 260\nNUMBER_OF_TAGS = 750\nNUMBER_OF_CREDITS = 300\nNUMBER_OF_USERS = 200\n</code></pre> <p>Generating Movie MetaData</p> <pre><code>movie_data = [generate_movie_metadata(movie_id) for movie_id in range(NUMBER_OF_MOVIES)]\nmovie_df = pd.DataFrame(movie_data)\nmovie_df.to_csv('movie_metadata.csv', index=False)\n</code></pre> <p>Generating Ratings Data</p> <pre><code>ratings_data = [generate_ratings(user_id, movie_id) for user_id in range(NUMBER_OF_RATINGS) for movie_id in range(NUMBER_OF_MOVIES)]\nratings_df = pd.DataFrame(ratings_data)\nratings_df.to_csv('ratings.csv', index=False)\n</code></pre> <p>Generating Credits Data</p> <pre><code>credits = [generate_credits(movie_id) for movie_id in range(NUMBER_OF_CREDITS )]\npd.DataFrame(credits).head()\ncredits_df = pd.DataFrame(credits)\ncredits_df.to_csv('credits_data.csv', index=False)\n</code></pre> <p>Generating Keywords Data</p> <pre><code>keywords = [generate_keywords(movie_id) for movie_id in range(NUMBER_OF_MOVIES)]\nkeywords_df = pd.DataFrame(keywords)\nkeywords_df_df = pd.DataFrame(keywords)\nkeywords_df.to_csv('keywords.csv', index=False)\n</code></pre> <p>Generating User Data</p> <pre><code>users = [generate_user(user_id) for user_id in range(1, NUMBER_OF_USERS + 1)]\nusers_df = pd.DataFrame(users)\n</code></pre> <p>Save user data to a CSV file</p> <pre><code>users_df.to_csv('users.csv', index=False)\n</code></pre> <p>...</p>"},{"location":"recommender/","title":"Recommender","text":"<p>This is the actual model that works for our package.</p>"},{"location":"recommender/#introduction","title":"Introduction","text":"<p>The <code>recommender.py</code> module contains logic for recommending movies to users based on certain criteria like user preferences, ratings, or other algorithms.</p>"},{"location":"recommender/#usage-example","title":"Usage Example","text":"<pre><code>def create_tfidf_matrix(self):\n    # Assuming that you want to calculate similarity based on the movie titles\n    tfidf = TfidfVectorizer(stop_words='english')\n    tfidf_matrix = tfidf.fit_transform(self.movie_data['title'])\n    return tfidf_matrix\n\ndef calculate_similarity(self):\n    # Compute the cosine similarity matrix\n    cosine_sim = linear_kernel(self.tfidf_matrix, self.tfidf_matrix)\n    return cosine_sim\n\ndef recommend_movies(self, movie_title, num_recommendations=10):\n    # Get the index of the movie that matches the title\n    indices = pd.Series(self.movie_data.index, index=self.movie_data['title']).drop_duplicates()\n    idx = indices[movie_title]\n\n    # Get the pairwise similarity scores of all movies with that movie\n    sim_scores = list(enumerate(self.similarity_matrix[idx]))\n\n    # Sort the movies based on the similarity scores\n    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)\n\n    # Get the scores of the 10 most similar movies\n    sim_scores = sim_scores[1:num_recommendations+1]\n\n    # Get the movie indices\n    movie_indices = [i[0] for i in sim_scores]\n\n    # Return the top 10 most similar movies\n    return list(self.movie_data['title'].iloc[movie_indices])\n\ndef get_movie_id(self, movie_title):\n    # Get the index of the movie that matches the title\n    indices = pd.Series(self.movie_data.index, index=self.movie_data['title']).drop_duplicates()\n    movie_id = indices.get(movie_title)\n\n    return movie_id\n</code></pre> <p>...</p>"},{"location":"schema/","title":"Schema","text":""},{"location":"schema/#usage","title":"Usage","text":"<pre><code>import logging\nimport os\n\nimport logging\nfrom ..logger import CustomFormatter\n\nlogger = logging.getLogger(os.path.basename(__file__))\nlogger.setLevel(logging.DEBUG)\nch = logging.StreamHandler()\nch.setLevel(logging.DEBUG)\nch.setFormatter(CustomFormatter())\nlogger.addHandler(ch)\n\n\nfrom sqlalchemy import create_engine,Column,Integer,String,Float, Date, DateTime, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, relationship\nfrom datetime import datetime\n\nengine=create_engine('sqlite:///temp.db')\n\nBase= declarative_base()\n</code></pre> <p>Define the RatingsSmall table</p> <pre><code>class Rating(Base):\n\n\"\"\"\n</code></pre> <p>Representation of the Ratings_small table, storing user ratings of movies.</p> <pre><code>Attributes\n----------\nuser_id : int\n    The ID of the user who provided the rating.\nmovie_id : int\n    The ID of the movie that was rated.\nrating : float\n    The rating given to the movie by the user.\n\"\"\"\n__tablename__ = \"Ratings_small\"\n\nuser_id = Column(Integer, ForeignKey('User.user_id'), primary_key=True)\nmovie_id = Column(Integer, ForeignKey('MovieMetadata.movie_id'), primary_key=True)\nrating = Column(Float)\n</code></pre> <p>Define the MovieMetadata table</p> <pre><code>class MovieMetadata(Base):\n\"\"\"\nRepresentation of the MovieMetadata table, storing metadata about movies.\n\nAttributes\n----------\nmovie_id : int\n    The primary key representing a unique ID for each movie.\ntitle : str\n    The title of the movie.\nbudget : float\n    The budget of the movie.\nrevenue : float\n    The revenue generated by the movie.\nrelease_date : date\n    The release date of the movie.\nlanguage : str\n    The language in which the movie was released.\nproduction_country : str\n    The country where the movie was produced.\nproduction_company : str\n    The company that produced the movie.\n\"\"\"\n__tablename__ = \"MovieMetadata\"\n\nmovie_id = Column(Integer, primary_key=True)\ntitle = Column(String)\nbudget = Column(Float)\nrevenue = Column(Float)\nrelease_date = Column(Date)\nlanguage = Column(String)\nproduction_country = Column(String)\nproduction_company = Column(String)\n\ncredits = relationship(\"Credits\", back_populates=\"movie\")\nkeywords = relationship(\"Keywords\", back_populates=\"movie\")\nlinks_small = relationship(\"LinksSmall\", back_populates=\"movie\")\n</code></pre> <p>Define the Credits table</p> <pre><code>class Credits(Base):\n\"\"\"\nRepresentation of the Credits table, storing information about the cast and crew of movies.\n\nAttributes\n----------\nmovie_id : int\n    The ID of the movie this entry relates to.\ncast : str\n    A string representation of the main cast involved in the movie.\ncrew : str\n    A string representation of the main crew involved in the making of the movie.\n\"\"\"\n__tablename__ = \"Credits\"\n\nmovie_id = Column(Integer, ForeignKey('MovieMetadata.movie_id'), primary_key=True)\ncast = Column(String)  # Assuming cast is a string field\ncrew = Column(String)  # Assuming crew is a string field\n\nmovie = relationship(\"MovieMetadata\", back_populates=\"credits\")\n</code></pre> <p>Define the Keywords table</p> <pre><code>class Keywords(Base):\n\"\"\"\nRepresentation of the plot_keywords table, storing keywords associated with the plot of movies.\n\nAttributes\n----------\nmovie_id : int\n    The ID of the movie this entry relates to.\nplot_keywords : str\n    A string of comma-separated keywords that describe the plot of the movie.\n\"\"\"\n__tablename__ = \"plot_keywords\"\n\nmovie_id = Column(Integer, ForeignKey('MovieMetadata.movie_id'), primary_key=True)\nplot_keywords = Column(String)\nmovie = relationship(\"MovieMetadata\", back_populates=\"keywords\")\n\nclass User(Base):\n\"\"\"\n</code></pre> <p>Representation of the User table, storing information about users.</p> <pre><code>Attributes\n----------\nuser_id : int\n    The primary key representing a unique ID for each user.\nfirst_name : str\n    The first name of the user.\nlast_name : str\n    The last name of the user.\nemail : str\n    The email address of the user.\nage : int\n    The age of the user.\n\"\"\"\n__tablename__ = \"User\"\n\nuser_id = Column(Integer, primary_key=True)\nfirst_name = Column(String)\nlast_name = Column(String)\nemail = Column(String)\nage = Column(Integer)\n</code></pre> <p>Define other user-related attributes here</p> <pre><code>ratings = relationship(\"RatingsSmall\")\n\n\nclass InOut(Base):\n\"\"\"\n</code></pre> <p>Representation of the InOut table, storing input movie names and corresponding output recommendations.</p> <pre><code>Attributes\n----------\nmovie_id : int\n    The primary key, representing the unique ID of the input movie.\ninput_movie : str\n    The name of the input movie.\noutput_recommendations : str\n    The recommended movies based on the input movie, stored as a string.\n\"\"\"\n__tablename__ = \"InOut\"\nmovie_id = Column(Integer, ForeignKey('MovieMetadata.movie_id'), primary_key=True)\ninput_movie = Column(String)\noutput_recommendations = Column(String)\n</code></pre> <p>Relationship to MovieMetadata</p> <pre><code>movie = relationship(\"MovieMetadata\")\n\nBase.metadata.create_all(engine)\n</code></pre> <p>...</p>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#introduction","title":"Introduction","text":"<p>This script is used to set up the movie database application, including installing dependencies, setting up the environment, and performing initial configurations.</p>"},{"location":"setup/#usage","title":"Usage","text":"<pre><code>from setuptools import setup, find_packages\n\nsetup(\n    author='Group7',\n    description='DS-223 Project',\n    name='etl',\n    version='0.1.0',\n    packages=find_packages(include=['etl','etl.*']),\n\n)\n</code></pre> <p>...</p>"},{"location":"sql_interactions/","title":"SQL Interactions","text":""},{"location":"sql_interactions/#introduction","title":"Introduction","text":"<p><code>sql_interactions.py</code> manages direct SQL interactions, such as complex queries, updates, or batch operations that are not handled by the <code>database.py</code> module.</p>"},{"location":"sql_interactions/#usage","title":"Usage","text":"<pre><code>logger = logging.getLogger(os.path.basename(__file__))\nlogger.setLevel(logging.DEBUG)\nch = logging.StreamHandler()\nch.setLevel(logging.DEBUG)\nch.setFormatter(CustomFormatter())\nlogger.addHandler(ch)\n</code></pre> <p>class SqlHandler:     \"\"\" A class to handle common SQL operations using sqlite3.</p> <p>Attributes     ----------     dbname : str         The name of the database.     table_name : str         The name of the table to perform operations on.     cnxn : sqlite3.Connection         The SQLite database connection object.     cursor : sqlite3.Cursor         The cursor object for the database.</p> <p>Methods     ------- close_cnxn() - Closes the database connection.</p> <p>get_table_columns() - Retrieves the column names from the table.</p> <p>truncate_table() - Deletes all records from the table.</p> <p>drop_table() - Drops the table from the database.</p> <p>insert_many(df) - Inserts multiple records from a DataFrame into the database table.</p> <p>from_sql_to_pandas(chunksize, id_value) - Loads data from the SQL table into a pandas DataFrame in chunks.</p> <p>update_table(condition) Updates records in the table based on a condition.</p> <pre><code>\"\"\"\ndef __init__(self, dbname:str,table_name:str) -&gt; None:\n    \"\"\"\n</code></pre> <p>Constructs all the necessary attributes for the SqlHandler object.</p> <pre><code>    Parameters\n    ----------\n    dbname : str\n</code></pre> <p>The name of the database file without the extension.         table_name : str The name of the table to perform operations on.         \"\"\"         self.cnxn=sqlite3.connect(f'{dbname}.db')         self.cursor=self.cnxn.cursor()         self.dbname=dbname         self.table_name=table_name</p> <pre><code>def close_cnxn(self)-&gt;None:\n    \"\"\"\n</code></pre> <p>Commits changes and closes the database connection.</p> <pre><code>    \"\"\"\n\n    logger.info('commiting the changes')\n    self.cursor.close()\n    self.cnxn.close()\n    logger.info('the connection has been closed')\n\ndef insert_one(self, data_to_insert: dict) -&gt; None:\n    \"\"\"\n</code></pre> <p>Inserts a single record into the table.</p> <pre><code>    Parameters\n    ----------\n    data_to_insert : dict\n</code></pre> <p>A dictionary where keys are column names and values are the corresponding data to insert.</p> <pre><code>    \"\"\"\n    columns = ', '.join(data_to_insert.keys())\n    placeholders = ', '.join(['?'] * len(data_to_insert))\n    values = tuple(data_to_insert.values())\n\n    query = f\"INSERT INTO {self.table_name} ({columns}) VALUES ({placeholders})\"\n    self.cursor.execute(query, values)\n    self.cnxn.commit()\n    logger.info('One record inserted successfully.')\n\n\ndef get_table_columns(self)-&gt;list:\n    self.cursor.execute(f\"PRAGMA table_info({self.table_name});\")\n    columns = self.cursor.fetchall()\n\n    column_names = [col[1] for col in columns]\n    logger.info(f'the list of columns: {column_names}')\n    # self.cursor.close()\n\n    return column_names\n\ndef truncate_table(self)-&gt;None:\n\n    query=f\"DROP TABLE IF EXISTS {self.table_name};\"\n    self.cursor.execute(query)\n    logging.info(f'the {self.table_name} is truncated')\n    # self.cursor.close()\n\ndef drop_table(self):\n\n    query = f\"DROP TABLE IF EXISTS {self.table_name};\"\n    logging.info(query)\n\n    self.cursor.execute(query)\n\n    self.cnxn.commit()\n\n    logging.info(f\"table '{self.table_name}' deleted.\")\n    logger.debug('using drop table function')\n\ndef insert_many(self, df:pd.DataFrame) -&gt; str:\n    \"\"\"\n</code></pre> <p>Inserts multiple records into the table from a DataFrame.</p> <pre><code>    Parameters\n    ----------\n    df : pd.DataFrame\n</code></pre> <p>The DataFrame containing the records to be inserted.</p> <pre><code>    Returns\n    -------\n    None\n    \"\"\"\n    df=df.replace(np.nan, None) # for handling NULLS\n    df.rename(columns=lambda x: x.lower(), inplace=True)\n    columns = list(df.columns)\n    logger.info(f'BEFORE the column intersection: {columns}')\n    sql_column_names = [i.lower() for i in self.get_table_columns()]\n    columns = list(set(columns) &amp; set(sql_column_names))\n    logger.info(f'AFTER the column intersection: {columns}')\n    ncolumns=list(len(columns)*'?')\n    data_to_insert=df.loc[:,columns]\n\n    values=[tuple(i) for i in data_to_insert.values]\n    logger.info(f'the shape of the table which is going to be imported {data_to_insert.shape}')\n    # if 'geometry' in columns: #! This block is usefull in case of geometry/geography data types\n    #     df['geometry'] = df['geometry'].apply(lambda geom: dumps(geom))\n    #     ncolumns[columns.index('geometry')]= 'geography::STGeomFromText(?, 4326)'\n\n    if len(columns)&gt;1:\n        cols,params =', '.join(columns), ', '.join(ncolumns)\n    else:\n        cols,params =columns[0],ncolumns[0]\n\n    logger.info(f'insert structure: colnames: {cols} params: {params}')\n    logger.info(values[0])\n    query=f\"\"\"INSERT INTO  {self.table_name} ({cols}) VALUES ({params});\"\"\"\n\n    logger.info(f'QUERY: {query}')\n\n    self.cursor.executemany(query, values)\n    try:\n        for i in self.cursor.messages:\n            logger.info(i)\n    except:\n        pass\n\n\n    self.cnxn.commit()\n\n\n    logger.warning('the data is loaded')\n\n    def from_sql_to_pandas(self) -&gt; pd.DataFrame:\n        \"\"\"\n</code></pre> <p>Reads data from the SQL table and returns a pandas DataFrame.</p> <pre><code>        Returns\n        -------\n        pd.DataFrame\n        The DataFrame containing all the data from the table.\n        \"\"\"\n    query = f\"SELECT * FROM {self.table_name}\"\n    df = pd.read_sql_query(query, self.cnxn)\n    logger.info('Data loaded into DataFrame from SQL table.')\n    return df\n\ndef from_sql_to_pandas(self, chunksize:int, id_value:str) -&gt; pd.DataFrame:\n    \"\"\"\n</code></pre> <p>Reads data from the SQL table in chunks and returns a single DataFrame.</p> <pre><code>    Parameters\n    ----------\n    chunksize : int\n        The number of rows per chunk to retrieve.\n    id_value : str\n        The column to order the results by.\n\n    Returns\n    -------\n    pd.DataFrame\n</code></pre> <p>The DataFrame containing all the data from the table.</p> <pre><code>    \"\"\"\n\n    offset=0\n    dfs=[]\n\n\n    while True:\n        query=f\"\"\"\n        SELECT * FROM {self.table_name}\n            ORDER BY {id_value}\n            OFFSET  {offset}  ROWS\n            FETCH NEXT {chunksize} ROWS ONLY  \n        \"\"\"\n        data = pd.read_sql_query(query,self.cnxn) \n        logger.info(f'the shape of the chunk: {data.shape}')\n        dfs.append(data)\n        offset += chunksize\n        if len(dfs[-1]) &lt; chunksize:\n            logger.warning('loading the data from SQL is finished')\n            logger.debug('connection is closed')\n            break\n    df = pd.concat(dfs)\n\n    return df\n\n\ndef update_table(self, set_values: dict, condition: str) -&gt; None:\n    \"\"\"\n</code></pre> <p>Updates records in the table based on a condition.</p> <pre><code>    Parameters\n    ----------\n    set_values : dict\n        A dictionary where keys are column names and values are the new data for these columns.\n    condition : str\n        A string that represents the SQL WHERE condition.\n    \"\"\"\n    set_clause = ', '.join([f\"{k} = ?\" for k in set_values.keys()])\n    values = list(set_values.values())\n\n    query = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition}\"\n    self.cursor.execute(query, values)\n    self.cnxn.commit()\n    logger.info('Table updated successfully.')\n</code></pre> <p>...</p>"}]}